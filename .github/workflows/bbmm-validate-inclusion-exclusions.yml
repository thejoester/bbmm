name: BBMM Validate Inclusion/Exclusion JSON (Discussions)

on:
  discussion:
    types: [opened, created, edited]
  discussion_comment:
    types: [created, edited]

permissions:
  contents: read
  discussions: write

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - name: Validate attached JSON and comment result
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const token = process.env.GITHUB_TOKEN;

            const extractCandidateUrls = (text) => {
              if (!text) return [];

              const urls = [];

              // Markdown links/images: [text](url) or ![text](url)
              const mdLinkRe = /\]\((https?:\/\/[^\s)]+)\)/g;
              let m;
              while ((m = mdLinkRe.exec(text)) !== null) urls.push(m[1]);

              // Raw URLs
              const rawRe = /(https?:\/\/[^\s)]+)/g;
              while ((m = rawRe.exec(text)) !== null) urls.push(m[1]);

              const unique = [...new Set(urls)];

              // Keep likely attachments:
              // - ends with .json (optionally with querystring)
              // - GitHub user-attachments links (often used for drag-drop uploads)
              return unique.filter(u =>
                /\.json(\?|$)/i.test(u) ||
                /\/user-attachments\//i.test(u)
              );
            };

            const tryDownloadText = async (url) => {
              const res = await fetch(url, {
                redirect: "follow",
                headers: token ? { Authorization: `Bearer ${token}` } : undefined
              });
              if (!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText}`);
              return await res.text();
            };

            const validateBundle = (data) => {
              const errors = [];

              if (!data || typeof data !== "object") {
                errors.push("File is not a JSON object.");
                return errors;
              }

              if (typeof data.schemaVersion !== "number") errors.push("Missing/invalid `schemaVersion` (must be a number).");
              if (typeof data.target !== "string" || !data.target.trim()) errors.push("Missing/invalid `target` (must be a non-empty string).");
              if (typeof data.targetVersion !== "string") errors.push("Missing/invalid `targetVersion` (must be a string; can be empty).");
              if (typeof data.foundryVersion !== "string") errors.push("Missing/invalid `foundryVersion` (must be a string; can be empty).");
              if (!Array.isArray(data.entries)) errors.push("Missing/invalid `entries` (must be an array).");

              if (Array.isArray(data.entries)) {
                data.entries.forEach((e, idx) => {
                  if (!e || typeof e !== "object") {
                    errors.push(`entries[${idx}] must be an object.`);
                    return;
                  }

                  const t = String(e.type ?? "").toLowerCase();
                  if (t !== "module" && t !== "setting") {
                    errors.push(`entries[${idx}].type must be "module" or "setting".`);
                    return;
                  }

                  if (t === "setting") {
                    if (typeof e.key !== "string" || !e.key.trim()) {
                      errors.push(`entries[${idx}].key is required for type "setting" (non-empty string).`);
                    }
                  }
                });
              }

              return errors;
            };

            // GraphQL comment helper (Discussions require GraphQL)
            const postComment = async (discussionNumber, body) => {
              // Fetch discussion node id
              const q = `
                query($owner:String!, $repo:String!, $number:Int!) {
                  repository(owner:$owner, name:$repo) {
                    discussion(number:$number) { id }
                  }
                }
              `;
              const qRes = await github.graphql(q, { owner, repo, number: discussionNumber });
              const discussionId = qRes?.repository?.discussion?.id;
              if (!discussionId) throw new Error(`Could not resolve discussion id for #${discussionNumber}`);

              const m = `
                mutation($discussionId:ID!, $body:String!) {
                  addDiscussionComment(input:{discussionId:$discussionId, body:$body}) {
                    comment { id url }
                  }
                }
              `;
              await github.graphql(m, { discussionId, body });
            };

            // Determine which discussion we're validating and what text to scan
            let discussionNumber = null;
            let bodiesToScan = [];

            if (context.eventName === "discussion") {
              discussionNumber = context.payload.discussion.number;
              bodiesToScan = [context.payload.discussion.body || ""];
            } else if (context.eventName === "discussion_comment") {
              discussionNumber = context.payload.discussion.number;

              const commentBody = context.payload.comment.body || "";
              bodiesToScan = [commentBody];

              // Also scan the discussion body as fallback
              const disc = await github.rest.discussions.get({
                owner, repo, discussion_number: discussionNumber
              });
              bodiesToScan.push(disc.data.body || "");
            } else {
              return;
            }

            // Find candidate attachment URLs
            const candidates = [];
            for (const b of bodiesToScan) {
              for (const u of extractCandidateUrls(b)) candidates.push(u);
            }
            const urls = [...new Set(candidates)];

            if (!urls.length) {
              if (context.eventName === "discussion") {
                const msg = [
                  "<!-- bbmm-validator -->",
                  "❌ I didn’t find an attached JSON file link in this discussion post.",
                  "",
                  "Attach your exported `.json` by dragging it into the editor, then edit the post to trigger validation."
                ].join("\n");
                await postComment(discussionNumber, msg);
              }
              return;
            }

            // Try each candidate URL until one parses as JSON
            let chosenUrl = null;
            let parsed = null;
            let lastDownloadErr = null;
            let lastParseErr = null;

            for (const u of urls) {
              try {
                const txt = await tryDownloadText(u);
                try {
                  const obj = JSON.parse(txt);
                  chosenUrl = u;
                  parsed = obj;
                  break;
                } catch (eParse) {
                  lastParseErr = eParse;
                  continue;
                }
              } catch (eDl) {
                lastDownloadErr = eDl;
                continue;
              }
            }

            if (!chosenUrl || !parsed) {
              const msg = [
                "<!-- bbmm-validator -->",
                "❌ I found attachment links, but none could be downloaded and parsed as JSON.",
                "",
                "**Links found:**",
                ...urls.map(u => `- ${u}`),
                "",
                lastDownloadErr ? `**Last download error:** ${String(lastDownloadErr.message ?? lastDownloadErr)}` : "",
                lastParseErr ? `**Last parse error:** ${String(lastParseErr.message ?? lastParseErr)}` : "",
                "",
                "Make sure the attached file is a `.json` export from BBMM and try again."
              ].filter(Boolean).join("\n");
              await postComment(discussionNumber, msg);
              return;
            }

            const errors = validateBundle(parsed);

            if (errors.length) {
              const msg = [
                "<!-- bbmm-validator -->",
                "❌ BBMM inclusion/exclusion file validation failed.",
                "",
                `**File:** ${chosenUrl}`,
                "",
                "**Problems found:**",
                ...errors.map(e => `- ${e}`),
                "",
                "Fix the JSON and re-attach (or attach a corrected file). Editing the post will trigger validation again."
              ].join("\n");
              await postComment(discussionNumber, msg);
              return;
            }

            const msg = [
              "<!-- bbmm-validator -->",
              "✅ BBMM inclusion/exclusion file looks valid.",
              "",
              `**File:** ${chosenUrl}`,
              "",
              "**Detected:**",
              `- target: \`${String(parsed.target)}\``,
              `- targetVersion: \`${String(parsed.targetVersion)}\``,
              `- foundryVersion: \`${String(parsed.foundryVersion)}\``,
              `- entries: \`${Array.isArray(parsed.entries) ? parsed.entries.length : 0}\``
            ].join("\n");

            await postComment(discussionNumber, msg);
